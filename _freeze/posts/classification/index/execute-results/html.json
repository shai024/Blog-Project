{
  "hash": "866a245a553ceed05bbf9d1888024cb8",
  "result": {
    "markdown": "---\ntitle: \"Classification\"\nauthor: \"Britney Aiken\"\ndate: \"2023-12-04\"\nimage: \"classification.jpg\"\ncode-fold: true\ncode-tools: true\ncode-block-bg: true\ncode-block-border-left: \"#31BAE9\"\ncode-summary: \"Show code\"\n---\n\n![Data classifcation is the foundation of many machine learing models. It allows us to make informed decisions based on patterns in the data.](classification.jpg)\n\n\n### What is Data Classification? Why is it Important in Machine Learning?\nData classification is the process of organizing and labeling data into predefined categories or classes. The goal is to train a machine learning model to recognize patterns within the data and accurately assign new instances to the appropriate class. The importance of data classification in machine learning lies in its ability to enable intelligent decision-making. By categorizing data, models can generalize from past experiences to make predictions or classifications on new, unseen data. This capability forms the foundation for a wide array of applications that impact our daily lives.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code code-summary=\"Show the code\"}\nimport sys\nfrom packaging import version\nimport sklearn\nfrom sklearn.datasets import fetch_openml\nimport matplotlib.pyplot as plt\n\n# Setup data visualization\ndef plot_digit(image_data):\n    image = image_data.reshape(28, 28)\n    plt.imshow(image, cmap=\"binary\")\n    plt.axis(\"off\")\n\nplt.rc('font', size=14)\nplt.rc('axes', labelsize=14, titlesize=14)\nplt.rc('legend', fontsize=14)\nplt.rc('xtick', labelsize=10)\nplt.rc('ytick', labelsize=10)\n\n# Import the dataset\nmnist = fetch_openml('mnist_784', as_frame=False)\nX, y = mnist.data, mnist.target\n\n\n# Plot example data\nplt.figure(figsize=(9, 9))\nfor idx, image_data in enumerate(X[:100]):\n    plt.subplot(10, 10, idx + 1)\n    plot_digit(image_data)\nplt.subplots_adjust(wspace=0, hspace=0)\nplt.show()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\britn\\anaconda3\\Lib\\site-packages\\sklearn\\datasets\\_openml.py:1002: FutureWarning: The default value of `parser` will change from `'liac-arff'` to `'auto'` in 1.4. You can set `parser='auto'` to silence this warning. Therefore, an `ImportError` will be raised from 1.4 if the dataset is dense and pandas is not installed. Note that the pandas parser may return different data types. See the Notes Section in fetch_openml's API doc for details.\n  warn(\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-2-output-2.png){width=688 height=684}\n:::\n:::\n\n\nThe figure above shows a sample of the MNIST dataset. The calculations and visuals below will reference this dataset.\n\n### Binary Classifiers\nBinary classification involves categorizing instances into one of two classes. These classes are usually boolean values(true or false; yes or no, 0 or 1). Evaluating the performance of a classifier is crucial to understand how well it generalizes to new data. Common performance measures include accuracy, precision, recall, F1 score, and the ROC-AUC curve. These metrics provide insights into the classifier's strengths and weaknesses,\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nsome_digit = X[7]\nplot_digit(some_digit)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-3-output-1.png){width=389 height=389}\n:::\n:::\n\n\nWe will train a binary classifier for the number `3`\n\n#### Confusion Matrix\nA confusion matrix provides a detailed breakdown of the model's predictions and the actual outcomes for each class. The four components of a confusion matrix are true positives (TP), true negatives (TN), false positives (FP), and false negatives (FN). These components are used to calculate performance metrics for a binary classifier.\n\n**True Positives (TP):** The number of instances that are actually positive and are correctly predicted as positive\n\n**True Negatives (TN):** The number of instances that are actually negative and are correctly predicted as negative\n\n**False Positives (FP):** The number of instances that are actually negative but are incorrectly predicted as positive (Type 1 error)\n\n**False Negatives (FN):** The number of instances that are actually positive but are incorrectly predicted as negative (Type 2 error)\n\nUsing these components, we can calculate several performance metrics. \n\n**Accuracy:** The proportion of correctly classified instances out of the total instances. `(TP+TN)/(TP+TN+FP+FN)`\n\n**Precision** The ratio of true positives to the total predicted positives. `TP/(TP+FP)`\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nfrom sklearn.metrics import precision_score\nfrom sklearn.linear_model import SGDClassifier\nfrom sklearn.model_selection import cross_val_predict\n\n# create the target vector\nX_train, X_test, y_train, y_test = X[:60000], X[60000:], y[:60000], y[60000:]\ny_train_3 = (y_train == '3')  \ny_test_3 = (y_test == '3')\n\n# train the classifier\nsgd_clf = SGDClassifier(random_state=42)\nsgd_clf.fit(X_train, y_train_3)\ny_train_pred = cross_val_predict(sgd_clf, X_train, y_train_3, cv=3)\n\n# get precision score\nprecision_score(y_train_3, y_train_pred) \n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n0.9111111111111111\n```\n:::\n:::\n\n\nThe presicion score after training the binary classifier\n\n**Recall:** The ratio of true positives to the total actual positives. `TP/(TP+FN)` This metric is also known as Sensitivity or True Positive Rate\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nfrom sklearn.metrics import recall_score\n\n# get recall score\nrecall_score(y_train_3, y_train_pred) \n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n0.655358016636764\n```\n:::\n:::\n\n\nThe recall score of the classifier\n\n**Specificity:** The ratio of true negatives to the total actual negatives. `TN/(TN+FP)` This metric is also known as the True Negative Rate\n\n**F1 Score:** The harmonic mean of precision and recall. Increasing precision reduces recall, and vice versa. This is called the precision/recall trade-off. `2×(Precision×Recall)/(Precision+Recall)`\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nfrom sklearn.metrics import f1_score\n\n# get F1 score\nf1_score(y_train_3, y_train_pred)\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n0.7623565126648326\n```\n:::\n:::\n\n\nThe F1 score of the classifier\n\n\n#### The Precsion/Recall (PR) Curve\nThe precision-recall curve is created by plotting precision against recall at different threshold values. Each point on the curve corresponds to a specific decision threshold used by the classifier to make predictions.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nfrom sklearn.metrics import precision_recall_curve\n\nthreshold = 3000\ny_scores = cross_val_predict(sgd_clf, X_train, y_train_3, cv=3, method=\"decision_function\")\n\n# plot and format the PR curve\nprecisions, recalls, thresholds = precision_recall_curve(y_train_3, y_scores)\nidx = (thresholds >= threshold).argmax() \n\nplt.figure(figsize=(6, 5)) \nplt.plot(recalls, precisions, linewidth=2, label=\"Precision/Recall curve\")\nplt.plot([recalls[idx], recalls[idx]], [0., precisions[idx]], \"k:\")\nplt.plot([0.0, recalls[idx]], [precisions[idx], precisions[idx]], \"k:\")\nplt.plot([recalls[idx]], [precisions[idx]], \"ko\",\n         label=\"Point at threshold 3,000\")\nplt.xlabel(\"Recall\")\nplt.ylabel(\"Precision\")\nplt.axis([0, 1, 0, 1])\nplt.grid()\nplt.legend(loc=\"lower left\")\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n<matplotlib.legend.Legend at 0x16b13afaa10>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-7-output-2.png){width=530 height=439}\n:::\n:::\n\n\nThe classifier's PR curve\n\n\n#### The ROC Curve\nThe Receiver Operating Characteristic (ROC) curve is another tool used with binary classifiers. It is similar to the precision/recall curve, but instead of plotting precision versus recall, the ROC curve plots the true positive rate (another name for recall) against the false positive rate (FPR).\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nfrom sklearn.metrics import roc_curve\n\n# calculate roc\nidx_for_90_precision = (precisions >= 0.90).argmax()\nthreshold_for_90_precision = thresholds[idx_for_90_precision]\nfpr, tpr, thresholds = roc_curve(y_train_3, y_scores)\nidx_for_threshold_at_90 = (thresholds <= threshold_for_90_precision).argmax()\ntpr_90, fpr_90 = tpr[idx_for_threshold_at_90], fpr[idx_for_threshold_at_90]\n\n# plot the roc curve\nplt.figure(figsize=(6, 5))  # extra code – not needed, just formatting\nplt.plot(fpr, tpr, linewidth=2, label=\"ROC curve\")\nplt.plot([0, 1], [0, 1], 'k:', label=\"Random classifier's ROC curve\")\nplt.plot([fpr_90], [tpr_90], \"ko\", label=\"Threshold for 90% precision\")\n\n# format the figure\nplt.xlabel('False Positive Rate')\nplt.ylabel('True Positive Rate (Recall)')\nplt.grid()\nplt.axis([0, 1, 0, 1])\nplt.legend(loc=\"lower right\", fontsize=13)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-8-output-1.png){width=530 height=439}\n:::\n:::\n\n\nThe higher the recall (TPR), the more false positives (FPR) the classifier produces. One way to compare classifiers is to measure the area under the curve (AUC). A perfect classifier will have a ROC AUC equal to 1, whereas a purely random classifier will have a ROC AUC equal to 0.5. \n\n### Multiclass Classification\nIn multiclass classification, instances are assigned to one of multiple classes. The model learns decision boundaries to separate instances belonging to different classes. The decision-making process involves assigning each instance to the class with the highest probability. Two  strategies for adapting binary classifiers to multiclass problems are One-vs-All (OvA) and One-vs-One (OvO).\n\n**One-vs-All:** Train a separate binary classifier for each class, treating it as the positive class and the rest as the negative class. The class with the highest score is then predicted.\n**One-vs-One:** Train a binary classifier for every pair of classes. In the prediction phase, each classifier votes for a class, and the class with the most votes is the final prediction.\n\n\n### Other Types of Classification\nMultilabel classification allows an instance to be associated with multiple labels or classes at the same time. This scenario is common in real-world problems where data points have many attributes.\n\nMultioutput Classification is a generalization of multilabel classification where each label can be multiclass\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}